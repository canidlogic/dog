#!/usr/bin/env perl
use strict;
use warnings;

# Non-core dependencies
use Imager;
use JSON::Tiny qw(decode_json);

# Yip imports
use Yip::Post;

=head1 NAME

dogpack.pl - Create a Yip MIME message that encodes a Dog-format photo
album.

=head1 SYNOPSIS

  ./dogpack.pl < album.json > album.msg
  ./dogpack.pl test large example.png -90

=head1 DESCRIPTION

Reads a JSON description of a photo album from input, and generates a
MIME message on output that can be directly imported into the Yip CMS.

B<Warning:> The whole encoded MIME message will have to be stored in
memory, so this is I<not> intended for large photo galleries, or you
will likely run out of memory!

If invoked with the C<test> syntax shown in the synopsis, this script
will instead generate a single transcoded and rotated image for
diagnostic purposes.  (Especially useful for making sure the rotation is
correct!)  The alternate syntax must begin with the C<test> parameter,
then a parameter selecting the resolution profile (C<tiny> C<small>
C<medium> or C<large>), then the path to the original photo file, and
finally the rotation in clockwise degrees (0, 90, 180, 270, -90, -180,
or -270).  The test syntax will write the transcoded JPEG file to
standard output.  If the requested resolution profile is not available
for this specific photo, the largest available resolution profile is
output instead.

=head2 Input format

The input file passed to this script must be in JSON format.  The
specific structure of the JSON required by this script is described in
this section.

An example input JSON looks like this:

  {
    "uid": 913055,
    "gdate": "2022-05-20T10:16:53",
    "gname": "Example photo gallery",
    "gdesc": "An example photo gallery.",
    "photos": [
      ["photo_1.jpg", 0],
      ["another_example.png", 0],
      ["interesting_dog.jpg", -90]
    ]
  }

The C<uid> property is the unique ID that will be given to the Yip post.
It must be in range [100000, 999999].  The C<gdate> property is the
timestamp given to the Yip post.  It must be in C<yyyy-mm-ddThh:mm:ss>
format with zero-padding to make each field a constant length.

The C<gname> property gives the name of the photo gallery and the
C<gdesc> property gives a textual description.  Both strings are allowed
to contain Unicode, as well as less-than sign, greater-sign, and
ampersand, but they may not contain any control characters in range
[0, 0x1f] or 0x7f.  Note that less-than sign, greater-sign, and
ampersand will automatically be escaped for HTML, so you can not include
any markup or entity references within this data.

The C<photos> property must map to an array or zero or more photo
subarrays.  Each photo subarray has exactly two elements, a string
giving the path to the original photo file, and an integer indicating
what rotation (clockwise, in degrees) to apply to the photo before
storing it.  Rotation may only have the values 0, 90, 180, 270, -90,
-180, and -270.

The photo files do I<not> need to be in JPEG, although this script will
automatically transcode all the packed images into JPEG.  Note that the
input photos should not use any transparency, since JPEG doesn't support
transparency.  Any of the image formats that the C<Imager> module can
detect are acceptable.

=head2 Output format

The basic output format is a MIME message generated by the C<Yip::Post>
module of the Yip CMS.  However, this MIME message has additional
structuring conventions beyond those specified by Yip, which are
described in the following subsections.

=head3 Attachment conventions

Dog has a special convention for attachment indices within the generated
post.  The first digit of the attachment index selects the resolution of
the image, which is in four different classes.  Digits 1 and 2 select
I<Tiny> class, digits 3 and 4 select I<Small> class, digits 5 and 6
select I<Medium> class, and digits 7 and 8 select I<Large> class.

The following table shows the first digit of the attachment index in the
first column, the class name in the second column, the standard basis
for this resolution class in the third column, and the number of pixels
of this resolution in the fourth column.  The number of pixels is always
equal to the width multiplied by the height from the third column.  The
specific aspect ratio of width to height given in the third column is
completely relevant; only the total number of pixels given in the fourth
column is meaningful.  For all rows except the first, the fifth column
is the the number of pixels in the current row divided by the number of
pixels from the previous row (approximately).

   Index |  Class |        Basis        | Pixels  | Increase
  =======+========+=====================+=========+==========
    1-2  | Tiny   |  320 x  240 : QVGA  |   76800 |    -
    3-4  | Small  |  640 x  480 : VGA   |  307200 |   4.0x
    5-6  | Medium | 1024 x  768 : XGA   |  786432 |   2.6x
    7-8  | Large  | 1920 x 1080 : 1080P | 2073600 |   2.6x

Each class therefore has two different digits associated with it.  Call
the lower digit of each class the I<lesser class digit> and the upper
digit of each class the I<greater class digit>.

While the first digit of the attachment index indicates the resolution
class as shown in the above table, the last three digits of the
attachment index select a specific photo from the gallery.  The photo
number can be in range [0, 1999], allowing for 2000 photos in the
gallery.  For photo numbers [0, 999], the lesser class digit is used as
the first digit of the attachment index and the last three digits of the
attachment index are equal to the photo number.  For photo numbers in
range [1000, 1999], the greater class digit is used as the first digit
of the attachment index and the last three digits of the attachment
index are equal to the photo number subtracted by 1000.

I<Warning:> Although this scheme allows for up to 2000 photos in a
single gallery, all photos will be packed in up to four versions each in
the generated MIME message.  A gallery of 2000 photos will in all
likelihood result in a generated MIME message that is so large it can't
be uploaded to Yip in any practical way.  In practice, it's a good idea
to stay very far below the limit of 2000 photos, splitting large
collections of photos into multiple galleries to keep the generated MIME
size practical.

Every photo in the gallery will have a Tiny-class attachment version.
Depending on the size of the photo, it may have additional resolution
class versions available.  All versions of the same photo will have the
same photo number and differ only by the first digit.  For example,
photo number 23 might have versions 1023 (Tiny), 3023 (Small), 5023
(Medium), and 7023 (Large).  Photo number 1509 might have versions
2509 (Tiny), 4509 (Small), 6509 (Medium), and 8509 (Large).

Let C<w> be the width in pixels of the original photo and C<h> be its
height in pixels.  Then, let C<p> be C<w> multiplied by C<h>, which is
the total number of pixels in the original photo.  If C<p> is less than
or equal to 2073600, then let C<mw> and C<mh> equal C<w> and C<h>.
Otherwise, Let C<ms> be the square root of the result of 2073600 divided
by C<p>, and then let C<mw> and C<mh> be C<w> and C<h> multiplied by
C<ms>, floored down to an integer value, and then increased if necessary
to be at least one.

The C<mw> and C<mh> values computed in the previous step are the
dimensions of the largest-resolution version of the photo that will be
stored in the gallery.  Either C<mw> and C<mh> are exactly equal to the
original dimensions, or they reduce the original photo to not exceed the
limit of 2073600 pixels, while maintaining the aspect ratio.

Let C<mp> be the result of multiplying C<mw> and C<mh>, which is the
total number of pixels in the largest-resolution version that will be
stored in the gallery.  If C<mp> is greater than 786432, then the
largest-resolution version is the Large resolution class.  Else, if
C<mp> is in range [307201, 786432], then the largest-resolution version
is the Medium resolution class.  Else, if C<mp> is in range [76801,
307200], then the largest-resolution version is the Small resolution
class.  Else, if C<mp> is in range [1, 76800], then the
largest-resolution version is the Tiny resolution class.

If a particular photo has a certain resolution class, then it must also
have all lesser resolution classes.  Therefore, by knowing the
resolution class of the largest version of the photo, one also knows all
of the resolution classes that will be generated for that particular
photo.  The exact resolution of the largest resolution class for a photo
was already computed with the C<mw> and C<mh> variables defined earlier.
To compute the exact resolution of another resolution class, let C<pt>
be the number of pixels for that resolution class given in the table
earlier in this section.  Once again letting C<p> be the total number of
pixels in the original photo, let C<sc> be the square root of the result
of C<pt> divided by C<p>, and then let C<rw> and C<rh> be the C<w> and
C<h> of the original photo multiplied by C<sc>, floored down to an
integer value, and then increased if necessary to be at least one.

All photos included in the packed MIME message will be re-encoded by
this script using the C<Imager> module with a JPEG quality of 90, to
ensure consistent encoding.  (In other words, the original photo file
is never directly included in the packed MIME message.)  The C<Imager>
JPEG encoder claims that it will not write any EXIF metadata.  Input
photos do not need to be JPEG, but note that since JPEG doesn't support
transparency, none of the input photos should use transparency or else
they will be flattened by the C<Imager> JPEG encoder by compositing
transparent pixels against a black background.

The Yip data type of all attached photos will be set to C<jpeg>.

=head3 Body conventions

The body of the Yip MIME messages generated by this script has a
standard format described in this subsection.

An example of a standard body looks like this:

  <TMPL_IF NAME=_partial>
  <div class="galleryname">Example photo gallery</div>
  <div class="gallerydesc">An example photo gallery.</div>
  </TMPL_IF>
  
  <TMPL_IF NAME=_full>
  <script id="galleryjson" type="application/json">
  {
    "gname": "Example photo gallery",
    "gdesc": "An example photo gallery.",
    "photos": [
      7000,
      7001,
      1002,
      3003,
      7004,
      5005
    ]
  }
  </script>
  </TMPL_IF>

This body has two completely separate renderings when in partial mode
(used within catalog and archive listing) and in full mode (used for the
actual gallery page).  In partial mode, the body merely gives the name
and description of the gallery that were given in the input JSON to this
script, putting each in its own DIV with its own DIV class for styling
purposes, as shown in the example above.

In full mode, the body adds a data-bearing script element containing
JSON describing the gallery.  The JSON is an object with C<gdesc> and
C<gname> properties storing the description and name of the gallery once
again, and then a C<photos> properties which maps to an array of
integers.  Each integer is attachment index of a photo in the gallery,
and the indices are sorted in ascending order of photo number.  Where a
specific photo number has multiple versions in various resolution
classes, the largest resolution class available is given.

Within the C<gdesc> and C<gname> property values, the less-than and
greater-than angle brackets as well as the ampersand will be escaped
using JSON numeric codepoint escapes.  When the JSON is parsed in
JavaScript, these escapes will transparently map back to the original
characters.  For the DIVs used in the partial rendering, the angle
brackets and ampersand will be escaped using HTML named entities.

=cut

# =========
# Constants
# =========

# Pixel-count limits for the different resolution profiles
#
my $TINY_LIMIT   =   76800;
my $SMALL_LIMIT  =  307200;
my $MEDIUM_LIMIT =  786432;
my $LARGE_LIMIT  = 2073600;

# ===============
# Local functions
# ===============

# calc_size(w, h, target)
#
# Compute a reduced image size that preserves aspect ratio but meets a
# given pixel count target (at least approximately).
#
# w and h are the original image dimensions in pixels.  These must both
# be integers that are greater than zero.
#
# target is the approximate maximum number of pixels in the reduced
# image.  It must be an integer that is greater than zero.
#
# This function returns a list of two integers, the first being the
# computed reduced width and the second being the computed reduced
# height.  If the given width and height are already within the target
# pixel count, they are returned as-is.  Both the computed width and
# the computed height will be integers that are at least one.
#
sub calc_size {
  # Get and check parameters
  ($#_ == 2) or die "Wrong number of parameters, stopped";
  
  my $w = shift;
  my $h = shift;
  my $p = shift;
  
  ((not ref($w)) and (not ref($h)) and (not ref($p))) or
    die "Wrong parameter types, stopped";
  ((int($w) == $w) and (int($h) == $h) and (int($p) == $p)) or
    die "Wrong parameter types, stopped";
  
  $w = int($w);
  $h = int($h);
  $p = int($p);
  
  (($w > 0) and ($h > 0) and ($p > 0)) or
    die "Parameters out of range, stopped";
  
  # Compute current total number of pixels
  my $cpc = $w * $h;
  
  # If current total number of pixels is within limit, return current
  # dimensions
  if ($cpc <= $p) {
    return ($w, $h);
  }
  
  # Not within limit, so compute scaling value
  my $sv = sqrt($p / $cpc);
  (($sv > 0.0) and ($sv <= 1.0)) or die "Numeric problem, stopped";
  
  # Scale each dimension and floor
  $w = int($sv * $w);
  $h = int($sv * $h);
  
  # Make sure each integer dimension at least one
  if ($w < 1) {
    $w = 1;
  }
  if ($h < 1) {
    $h = 1;
  }
  
  # Return computed dimensions
  return ($w, $h);
}

# load_image(path, rotation)
#
# Read an image from a file path and transcode into JPEG, optionally
# applying a given rotation and generating all the necessary profiles.
#
# The rotation must be an integer that has one of the following values:
# 0, 90, 180, 270, -90, -180, -270.  Rotations are given in degress in
# clockwise direction.
#
# Fatal errors occur if there are any problems.
#
# If successful, an array is returned with one to four elements,
# representing the generated profiles from smallest to largest.  Each
# element is a scalar reference to a binary string storing the JPEG
# file bytes.
#
sub load_image {
  # Get and check parameters
  ($#_ == 1) or die "Wrong number of parameters, stopped";
  
  my $path     = shift;
  my $rotation = shift;
  
  ((not ref($path)) and (not ref($rotation))) or
    die "Wrong parameter type, stopped";
  
  (-f $path) or die "Can't find photo '$path', stopped";
  
  (int($rotation) == $rotation) or
    die "Wrong parameter type, stopped";
  
  $rotation = int($rotation);
  (($rotation == 0) or ($rotation == 90) or ($rotation == 180) or
      ($rotation == 270) or ($rotation == -90) or
      ($rotation == -180) or ($rotation == -270)) or
    die "Parameter out of range, stopped";
  
  # Convert negative rotations to equivalent positive value
  if ($rotation < 0) {
    $rotation = $rotation + 360;
  }
  
  # Load the image
  my $img = Imager->new(file => $path) or
    die "Failed to read image at '$path': " . Imager->errstr();
  
  # If there is a rotation, apply it to the original image
  if ($rotation != 0) {
    $img = $img->rotate(right => $rotation) or
      die "Failed to rotate image '$path': " . $img->errstr();
  }
  
  # Get the rotated image width and height
  my $rw = $img->getwidth();
  my $rh = $img->getheight();
  
  ((defined $rw) and (defined $rh) and
    (int($rw) == $rw) and (int($rh) == $rh) and
    ($rw > 0) and ($rh > 0)) or
    die "Failed to dimension image '$path', stopped";
  
  # Compute the current pixel count
  my $rp = $rw * $rh;
  
  # If current pixel count exceeds the largest limit, reduce the image
  # to the largest limit
  if ($rp > $LARGE_LIMIT) {
    ($rw, $rh) = calc_size($rw, $rh, $LARGE_LIMIT);
    $rp = $rw * $rh;
    $img = $img->scale(xpixels => $rw) or
      die "Failed to scale image '$path': " . $img->errstr();
  }
  
  # Based on the current pixel count, figure out how many generated
  # images there will be
  my $gen_count;
  if ($rp > $MEDIUM_LIMIT) {
    $gen_count = 4;
  
  } elsif ($rp > $SMALL_LIMIT) {
    $gen_count = 3;
    
  } elsif ($rp > $TINY_LIMIT) {
    $gen_count = 2;
    
  } else {
    $gen_count = 1;
  }
  
  # Generate each of the transcoded images
  my @result;
  for(my $x = 0; $x < $gen_count; $x++) {
    # Different handling depending if this is the last image
    if ($x < $gen_count - 1) {
      # Not the last image, so get the current limit value
      my $limitval;
      if ($x == 0) {
        $limitval = $TINY_LIMIT;
        
      } elsif ($x == 1) {
        $limitval = $SMALL_LIMIT;
        
      } elsif ($x == 2) {
        $limitval = $MEDIUM_LIMIT;
        
      } else {
        die "Unexpected";
      }
      
      # Compute the reduced image dimensions
      my ($tw, $th) = calc_size($rw, $rh, $limitval);
      
      # Scale the image
      my $si = $img->scale(xpixels => $tw) or
        die "Failed to scale image '$path': " . $img->errstr();
      
      # Write the scaled image
      my $data;
      $si->write(data => \$data, type => 'jpeg', jpegquality => 90) or
        die "Failed to transcode '$path': " . $si->errstr();
      push @result, (\$data);
      
    } else {
      # This is the last image, so we write the source image
      my $data;
      $img->write(data => \$data, type => 'jpeg', jpegquality => 90) or
        die "Failed to transcode '$path': " . $img->errstr();
      push @result, (\$data);
    }
  }
  
  # Return the generated images
  return @result;
}

# ==================
# Program entrypoint
# ==================

# Switch input and output to raw binary
#
binmode(STDIN , ":raw") or die "Failed to set binary input, stopped";
binmode(STDOUT, ":raw") or die "Failed to set binary output, stopped";

# Handle the special test invocation
#
if (($#ARGV >= 0) and ($ARGV[0] eq 'test')) {
  # Test invocation, so check argument count
  ($#ARGV == 3) or
    die "Wrong number of parameters for test invocation, stopped";
  
  # Get and check the requested profile and translate it into an array
  # index for arrays returned from load_image
  my $result_i;
  if ($ARGV[1] eq 'tiny') {
    $result_i = 0;
  
  } elsif ($ARGV[1] eq 'small') {
    $result_i = 1;
    
  } elsif ($ARGV[1] eq 'medium') {
    $result_i = 2;
    
  } elsif ($ARGV[1] eq 'large') {
    $result_i = 3;
    
  } else {
    die "Unrecognized resolution profile '$ARGV[1]', stopped";
  }
  
  # Get and check the photo file path
  my $photo_path = $ARGV[2];
  (-f $photo_path) or
    die "Can't find photo file '$photo_path', stopped";
  
  # Get the rotation and convert to integer
  my $rotation;
  if ($ARGV[3] eq '0') {
    $rotation = 0;
    
  } elsif ($ARGV[3] eq '90') {
    $rotation = 90;
    
  } elsif ($ARGV[3] eq '180') {
    $rotation = 180;
    
  } elsif ($ARGV[3] eq '270') {
    $rotation = 270;
    
  } elsif ($ARGV[3] eq '-90') {
    $rotation = -90;
    
  } elsif ($ARGV[3] eq '-180') {
    $rotation = -180;
    
  } elsif ($ARGV[3] eq '-270') {
    $rotation = -270;
    
  } else {
    die "Unrecognized rotation angle '$ARGV[3]', stopped";
  }
  
  # Load the image file and transcode
  my @result;
  eval {
    @result = load_image($photo_path, $rotation);
  };
  if ($@) {
    die "Failed to transcode image: $@";
  }
  
  # If requested resolution index beyond the end of result array, set to
  # last element
  if ($result_i > $#result) {
    $result_i = $#result;
  }
  
  # Print the transcoded JPEG file to standard output
  print "${$result[$result_i]}";
  
  # Finish script
  exit;
}

# If we got here, make sure we didn't get parameters
#
($#ARGV < 0) or die "Unrecognized program arguments, stopped";

# Read all raw binary input
#
my $raw_input;
eval {
  local $/;
  $raw_input = <STDIN>;
};
if ($@) {
  die "Failed to read binary input: $@";
}

# Parse as JSON
#
my $json;
eval {
  $json = decode_json $raw_input;
  undef $raw_input;
};
if ($@) {
  die "Failed to parse input JSON: $@";
}

# Check we got a JSON object with the required properties and that those
# required properties have the proper types
#
(ref($json) eq 'HASH') or
  die "Input JSON must be a JSON object, stopped";

for my $rpn ('uid', 'gdate', 'gname', 'gdesc', 'photos') {
  (defined $json->{$rpn}) or
    die "Input JSON missing '$rpn' property, stopped";
}

for my $rpn ('uid', 'gdate', 'gname', 'gdesc') {
  (not ref($json->{$rpn})) or
    die "Input JSON '$rpn' property must be scalar, stopped";
}

for my $rpn ('gname', 'gdesc') {
  ($json->{$rpn} =~
      /\A[\x{20}-\x{7e}\x{80}-\x{d7ff}\x{e000}-\x{10ffff}]*\z/) or
    die "Input JSON '$rpn' contains invalid codepoints, stopped";
}

($json->{'uid'} =~ /\A[1-9][0-9]{5}\z/) or
  die "Input JSON 'uid' is invalid, stopped";

(ref($json->{'photos'}) eq 'ARRAY') or
  die "Input JSON 'photos' property must be array, stopped";
(scalar(@{$json->{'photos'}}) <= 2000) or
  die "Input JSON 'photos' array may have at most 2000 photos, stopped";

for my $pav (@{$json->{'photos'}}) {
  (ref($pav) eq 'ARRAY') or
    die "Input JSON 'photos' array must contain subarrays, stopped";
  (scalar(@$pav) == 2) or
    die "Input JSON 'photos' subarrays must have length two, stopped";
  (not ref($pav->[0])) or
    die "Input JSON 'photos' file paths must be scalars, stopped";
  (-f $pav->[0]) or
    die "Can't find photo file '$pav->[0]', stopped";
  (not ref($pav->[1])) or
    die "Input JSON 'photos' rotations must be scalars, stopped";
  (($pav->[1] eq '0') or ($pav->[1] eq '90') or ($pav->[1] eq '180') or
    ($pav->[1] eq '270') or ($pav->[1] eq '-90') or
    ($pav->[1] eq '-180') or ($pav->[1] eq '-270')) or
    die "Invalid input JSON rotation: '$pav->[1]', stopped";
}

# Create a new post object that we will fill in
#
my $yp = Yip::Post->create;

# Set the UID and date of the post; since we didn't check the date
# string earlier, we will let Yip::Post do that for us
#
$yp->uid(int($json->{'uid'}));
eval {
  $yp->date($json->{'gdate'});
};
if ($@) {
  die "Input JSON 'gdate' invalid: $@";
}

# Transcode and attach all images; simultaneously, build an array that
# stores the attachment indices of the largest resolution class of each
# photo in ascending order of photo number
#
my @ati;
my $photo_count = 0;
for my $pav (@{$json->{'photos'}}) {
  
  # Update status
  my $progress = $photo_count + 1;
  my $total = scalar(@{$json->{'photos'}});
  print { \*STDERR } "Transcoding $progress out of $total...\n";
  
  # Check photo count
  ($photo_count < 2000) or die "Unexpected";
  
  # Transcode this photo
  my @tca;
  eval {
    @tca = load_image($pav->[0], $pav->[1]);
  };
  if ($@) {
    die "Failed to load image '$pav->[0]': $@";
  }
  
  # Figure out the attachment index of the maximum resolution class for
  # this photo
  my $max_ati;
  if ($#tca == 0) {
    $max_ati = 1000 + $photo_count;
    
  } elsif ($#tca == 1) {
    $max_ati = 3000 + $photo_count;
    
  } elsif ($#tca == 2) {
    $max_ati = 5000 + $photo_count;
    
  } elsif ($#tca == 3) {
    $max_ati = 7000 + $photo_count;
    
  } else {
    die "Unexpected";
  }
  
  # Append the attachment index of the maximum resolution class to the
  # ati array
  push @ati, ($max_ati);
  
  # Attach each resolution class to the post
  for(my $i = 0; $i <= $#tca; $i++) {
    # Determine attachment index
    my $ai;
    if ($i == 0) {
      $ai = 1000 + $photo_count;
    } elsif ($i == 1) {
      $ai = 3000 + $photo_count;
    } elsif ($i == 2) {
      $ai = 5000 + $photo_count;
    } elsif ($i == 3) {
      $ai = 7000 + $photo_count;
    } else {
      die "Unexpected";
    }
    
    # Add attachment
    $yp->attnew($ai, 'jpeg', ${$tca[$i]});
  }
  
  # Increase photo count
  $photo_count++;
}

# Escape the photo gallery name and description in HTML style
#
my $pgn_html = $json->{'gname'};
my $pgd_html = $json->{'gdesc'};
for(my $i = 0; $i < 2; $i++) {
  # Get current variable
  my $str;
  if ($i == 0) {
    $str = $pgn_html;
  } elsif ($i == 1) {
    $str = $pgd_html;
  } else {
    die "Unexpected";
  }
  
  # First, escape any literal ampersands
  $str =~ s/&/&amp;/g;
  
  # Second, escape angle brackets
  $str =~ s/</&lt;/g;
  $str =~ s/>/&gt;/g;
  
  # Set current variable
  if ($i == 0) {
    $pgn_html = $str;
  } elsif ($i == 1) {
    $pgd_html = $str;
  } else {
    die "Unexpected";
  }
}

# Escape the photo gallery name and description in JSON style, also
# escaping ampersand and angle brackets
#
my $pgn_json = $json->{'gname'};
my $pgd_json = $json->{'gdesc'};
for(my $i = 0; $i < 2; $i++) {
  # Get current variable
  my $str;
  if ($i == 0) {
    $str = $pgn_json;
  } elsif ($i == 1) {
    $str = $pgd_json;
  } else {
    die "Unexpected";
  }
  
  # First, escape any literal backslashes
  $str =~ s/\\/\\\\/g;
  
  # Second, escape any literal double quotes
  $str =~ s/"/\\"/g;
  
  # Verify (again) that there are no ASCII control codes or surrogates
  (not ($str =~ /[\x{0}-\x{1f}\x{7f}\x{d800}-\x{dfff}]/)) or
    die "Unexpected";
  
  # Third, escape ampersand and angle brackets
  $str =~ s/&/\\u0026/g;
  $str =~ s/</\\u003c/g;
  $str =~ s/>/\\u003e/g;
  
  # Set current variable
  if ($i == 0) {
    $pgn_json = $str;
  } elsif ($i == 1) {
    $pgd_json = $str;
  } else {
    die "Unexpected";
  }
}

# Begin the body code
#
my $body =
qq<<TMPL_IF NAME=_partial>
<div class="galleryname">$pgn_html</div>
<div class="gallerydesc">$pgd_html</div>
</TMPL_IF>
<TMPL_IF NAME=_full>
<script id="galleryjson" type="application/json">
{
  "gname": "$pgn_json",
  "gdesc": "$pgd_json",
  "photos": [>;

# Add all the attachment indices to the body code
#
for(my $i = 0; $i <= $#ati; $i++) {
  if ($i > 0) {
    $body = $body . ",\n";
  } else {
    $body = $body . "\n";
  }
  $body = $body . "    $ati[$i]";
}

# Finish the body code
#
$body = $body . q<
  ]
}
</script>
</TMPL_IF>
>;

# Set the body code
#
$yp->body($body);

# Generate MIME message and print it to output
#
print $yp->encodeMIME;

=head1 AUTHOR

Noah Johnson, C<noah.johnson@loupmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 Multimedia Data Technology Inc.

MIT License:

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
